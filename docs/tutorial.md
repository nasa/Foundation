# Foundation SDK Tutorial

## Introduction

The best way to leverage benefits from the Foundation SDK is, at the risk of
seeming obvious, is to "learn by doing." The following list of example
applications serve as an introduction to SDK features, each example building
upon the complexity of the previous. The last example brings together all of the
features that a typical Foundation-based application would require.

## Step 1: An Insistent "Hello World"

Keeping with computer science tradition, the very first example will just
indicate to all that everything is just fine with a "Hello World" message. The
peculiar trait that will set this example apart from the typical is the
insistence of the message: it will print "Hello World" once per second until it
is stopped. Despite its simplicity, this example will introduce several
fundamental concepts:

1. Basic application project structure.
1. Several features offered "out of the box" by Foundation.
1. Application initialization and termination.
1. Periodic timers.
1. Attaching logic to input stimuli.

[Tutorial Step 1](tutorial_steps/step_1.md)

## Step 2: Reaching Out over Serial I/O

The primary driver for the genesis of Foundation was the authoring of
applications that could communicate with peripherals. Thus, interfacing over
input/output (I/O) is rightfully introduced very early in this learning journey.
Although not actually interacting with an instrument, this example builds upon
[Step 1](#step-1-an-insistent-hello-world) by first initializing a serial port
and then by printing the expected "Hello World" message through that serial
port. This example introduces:

1. Serial port initialization and termination.
1. Configuration and interpretation of command-line arguments.
1. Sending information to peripherals over external I/O.

[Tutorial Step 2](tutorial_steps/step_2.md)

## Step 3: Listening and Reacting

Completing the circle started in [Step 2](#step-2-reaching-out-over-serial-io),
this example builds upon it by listening for incoming transmissions on the same
serial port and echoing such transmissions to the screen and back through the
serial port. This example introduces:

1. Handling stimuli generated by external I/O.

[Tutorial Step 3](tutorial_steps/step_3.md)

## Step 4: I/O Diversification

The fundamentals regarding input/output interactions within a Foundation-based
application are brought to bear in this example by introducing a new form of
communication: the Controller Area Network (CAN) bus. The example logic will
show concurrent input and output over a CAN bus port. This example introduces:

1. CAN bus port initialization and termination.
1. Sending and receiving CAN frames.
1. Identifying portions of a CAN frame.

[Tutorial Step 4](tutorial_steps/step_4.md)

## Step 5: More I/O Diversity

The CAN bus transport introduced in [Step 4](#step-4-io-diversification) is
quite similar to connection-less networking as that offered by the User Datagram
Protocol (UDP). Thus, this example is a slight variation on the aforementioned,
swapping in UDP sockets in place of CAN bus ports. This example introduces:

1. UDP/IP socket initialization and termination.
1. Sending and receiving UDP datagrams.

[Tutorial Step 5](tutorial_steps/step_5.md)

## Step 6: Connection-based I/O

Up until this example, all of the I/O shown has been relatively simple to set
up, with the example in [Step 5](#step-5-more-io-diversity) being the most
sophisticated by introducing the binding of an I/O port to a particular address.
The Transmission Control Protocol (TCP) raises the level of sophistication by
introducing roles to the communication end points: a "server" and a "client."
This example introduces:

1. TCP/IP client and server initialization and termination.
1. Handling information streams over a TCP/IP connection.
1. Managing connection state.

[Tutorial Step 6](tutorial_steps/step_6.md)

## Step 7: Software Bus Participation Basics

Another big motivation behind putting together the Foundation was the
standardization of communication between a heterogenous set of instruments by
introducing a common way to interact with them. Although any of the I/O
mechanisms introduced up to this point could be used to achieve this goal, there
is one higher-level protocol that brings with it many desirable features "out of
the box": the Object Management Group's (OMG) Data Distribution Service (DDS).
This example introduces:

1. DDS Participant initialization and termination.
1. DDS message structure and topic definition.
1. Publishing messages to other participants.
1. Listening, and reacting to, incoming DDS messages.

As of this writing, the OMG maintains two (2) Platform-Specific Modules (PSM)
for the C++ language. Depending on how the Foundation library was built (either
with [`DdsKit`](./building.md#building) or
[`IsoDdsKit`](./building.md#building-with-isoddskit)). These two options are
mutually exclusive; only one may be built into a Foundation product.

### Step 7 Variant: Classic C++ DDS

One DDS PSM is solely based on the mapping of abstract definitions written in
the OMG Interface Definition Language (IDL) to C++. This variant is referred to
in the Foundation as the "Classic C++" variant.

[Tutorial Step 7: Classic C++ Variant](tutorial_steps/step_7.md)

### Step 7a Variant: ISO/IEC C++ DDS

The second PSM for the C++ language prescribes the Application Programming
Interface (API) irrespective of IDL mapping. It is identified by the OMG as the
[OMG ISO/IEC C++ PSM][OmgIsoCxxPsm].

[Tutorial Step 7a: ISO/IEC C++ Variant](tutorial_steps/step_7a.md)

## Step 8: Instrument Agent Primer

Standardizing communication with a variety of instruments over a common
protocol, regardless of the instrument's native communication interface, begins
with translating between those two realms. The task of translation is the very
core of what an "Instrument Agent" is: a representative for a particular
instrument in a common software communications bus. The Foundation was designed
from the beginning to implement the common software bus concept in terms of the
DDS protocol. This example brings several of the concepts introduced in previous
steps together in order to implement the most basic instrument agent behavior:
translating between a native interface and a DDS software bus.

Similar to Tutorial Step 7, this step brings with it two (2) variants based on
what DDS C++ PSM the Foundation library was built with.

### Step 8 Variant: Classic C++ DDS

For Foundation builds that use the "Classic C++" DDS PSM:

[Tutorial Step 8](tutorial_steps/step_8.md)

### Step 8 Variant: ISO/IEC C++ DDS

For Foundation builds that use the "ISO/IEC C++" DDS PSM:

[Tutorial Step 8a: ISO/IEC C++ Variant](tutorial_steps/step_8a.md)


[OmgIsoCxxPsm]: https://www.omg.org/spec/DDS-PSM-Cxx/1.0/About-DDS-PSM-Cxx "OMG ISO/IEC C++ PSM"